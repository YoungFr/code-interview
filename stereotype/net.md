# 基础

- 网络模型概览

  应用层工作在`用户态`，传输层及以下工作在`内核态`

  传输层根据报文中的`端口号`决定将报文发送给哪个应用

  `网络层`负责将数据从一个设备传输到另一个设备；设备的地址通过 IP 地址标识

  IP 协议的两个功能：`寻址`和`路由`

  IP 地址分成`网络号`和`主机号`两部分

  将`子网掩码`与 IP 地址相与得到网络号，将子网掩码取反后再与 IP 地址相与得到主机号

- 键入网址到显示网页的过程

  1. 解析 URL 确定 Web 服务器名和要请求的资源的路径

  2. 生成 HTTP 请求信息

  3. 使用 DNS 查询域名对应的 IP 地址

     涉及的服务器：`本地` DNS 服务器（DNS 解析器）、`根`域名服务器、`顶级`域名服务器、`权威`域名服务器

     DNS 缓存：浏览器缓存 => OS 缓存 => hosts 文件 => 本地 DNS 服务器

  4. 可靠传输 —— 三次握手建立 TCP 连接

  5. 远程定位 —— 使用 IP 发送网络包

  6. 两点传输 —— MAC 和交换机

  7. 离开子网 —— 路由器

- Linux 如何收发网络包

  TODO

# HTTP

- 什么是 HTTP 协议？

  超文本传输协议 HTTP 是一个在计算机世界里专门在`两点之间`（服务器 `<-->` 客户端、服务器 `<-->` 服务器）

  `传输`文字、图片、音频、视频等`超文本`数据的约定和规范。

- 状态码

  1. `1XX` —— 表示中间状态的提示信息

  2. `2XX`  —— 成功处理客户端请求

     `200 OK` -> 正常

     `202 No Content` -> 响应头没有 body 数据

     `206 Partial Content` -> 分块下载或断点续传

  3. `3XX` —— 重定向，请求资源变动，需要用新的 URL 获取资源

     `301 Moved Permanently` -> 永久重定向

     `302 Found` -> 临时重定向

     `304 Not Modified` -> 资源未修改，可以使用过期的缓存，与重定向无关

  4. `4XX` —— 客户端错误

     `400 Bad Request` -> 笼统的请求报文错误

     `403 Forbidden` -> 资源禁止访问

     `404 Not Found` -> 资源不存在

  5. `5XX` —— 服务端错误

     `500 Internal Server Error` -> 笼统的服务器错误

     `501 Not Implemented` -> 请求功能不支持

     `502 Bad Gateway` -> 服务器作为网关或代理访问后端服务器时出错

     `503 Service Unavailable` -> 服务器忙

- 常见字段

  `Host` —— 客户端发送请求时指定服务器域名

  `Content-Length` —— 服务器表明本次回应的数据长度，用于解决 TCP 粘包问题

  `Connection` —— 客户端使用 `Connection: Keep-Alive` 要求服务器使用长连接机制

  `Accept` —— 客户端声明自己可以接受的数据格式

  `Content-Type` —— 服务器表明本次回应使用的数据格式

  `Content-Encoding` —— 表明服务器使用的数据压缩方式

- GET 与 POST

  GET 的语义：从服务器获取指定的资源

  POST 的语义：根据请求负荷（报文主体）对指定的资源做出处理

  `安全` —— 请求方法不会破坏服务器资源 `幂等` —— 多次执行相同操作的结果都是相同的

  GET 是安全、幂等、可缓存的；POST 是不安全、不幂等、不可缓存的

- 缓存

  强制缓存 —— 如果浏览器判断缓存没有过期则使用浏览器本地缓存

  通过使用 `Cache-Control` 头部设置过期时间来实现

  协商缓存 —— 通过服务器告知客户端是否可以使用缓存

  有基于时间（`Last-Modified/If-Modified-Since`）和基于唯一标识（`Etag/If-None-Match`）两种实现方式

  `只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求`

- HTTP/1.1 的优缺点与性能

  `简单、灵活、易扩展、跨平台` VS `无状态、不安全的明文传输`

  提高性能的两个手段：`长连接` 和 `管线化` （有但从未被使用）

- HTTP的 问题、解释以及 HTTPS 的解决方案

  `窃听` -> 明文传输内容会被获取 -> `加密传输` -> 非对称加密 + 对称加密

  `篡改` -> 在通信内容中植入垃圾 -> 

  完整性 -> `摘要算法` -> 对传输内容使用哈希算法计算出指纹

  可靠性 -> `数字签名` -> 对摘要算法算出的指纹使用私钥加密

  `冒充` -> 服务器身份被非法冒充 -> `数字证书` -> 使用 CA 证书验证公钥的合法性

- TLS 四次握手

  基本过程包括索要公钥和密钥协商两步

  第一步：客户端发送 `ClientHello` 请求 -> TLS 版本、随机数、密码套

  第二步：服务端发回 `ServerHello` 响应 ->  确认 TLS 版本、随机数、密码套、证书

  第三步：客户端验证证书 -> 取出公钥 -> 发送使用公钥加密的预主密钥、加密算法改变通知、客户端握手结束通知

  第四步：计算会话密钥 、加密算法改变通知、服务端握手结束通知

  在第三步和第四步中客户端和服务器各自利用加密算法根据三个随机数算出会话密钥

# TCP/UDP

- TCP 关键字

  **面向连接、可靠、字节流**

- TCP 头格式

  重要的字段：源端口/目的端口、**序列号（防止乱序）**、**确认应答号（防止丢包）**、控制位（ACK/RST/SYN/FIN）

- 端口重用？

  - TCP 和 UDP **可以** 绑定同一个端口：二者在内核中是独立的两个软件模块
  - 多个 TCP **可以** 绑定同一端口（但是 IP 地址不能相同）
  - 客户端的端口 **可以** 重复使用（四元组不同即可）
