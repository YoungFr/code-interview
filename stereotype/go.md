# 基础

- 特点：简单、并发、垃圾回收

- 类型 `string` 和 `[]byte` 对比：不可变 `VS` 可变、Unicode 字符 `VS` 字节、可相互转换

- 数组 `VS` 切片：固定长度 `VS` 可变长度、值类型 `VS` 引用类型

- 切片扩容：小于 1024 时每次翻倍，大于 1024 时每次增长 1.25 倍

- `map` 的实现原理：散列表 -> 哈希函数 -> 存储桶 -> 链表 or 红黑树

- `map` 元素数量达到负载因子时进行扩容：容量翻倍 -> 分配 -> 重哈希 -> 切换新 -> 释放旧

- 内置的 `panic` 和 `recover` 函数

  - 函数 `panic` 用于引发运行时错误，立即停止当前 goroutine 运行并按调用栈

    向上搜寻，执行每个调用者的 `defer` 函数，最终程序终止

  - 函数 `recover` 用于从 `panic` 引发的错误中恢复，捕获 `panic` 的值

- `defer` 函数：按 `LIFO` 顺序执行、函数参数预先计算、可以修改（有名返回值）函数的返回值

- 执行顺序：`import` -> `const` -> `var` -> `init()` -> `main()`

- 局部变量的逃逸分析：如果变量离开作用域后没有被引用，分配到栈上，否则分配到堆上

- 两个接口的比较：只有都为 `nil` 或类型 `T` 和值 `V` 同时相等时才相等

# 并发

- 协程是轻量级的用户态线程，由 Go 调度器进行管理。协程之间通过管道通信

- `Mutex` 的两种模式：正常（FIFO）和饥饿（一定的公平原则）模式

  **正常模式**：加锁时如果当前 `Locked` 位为 1 ，说明该锁当前由其他协程持有，尝试加锁的协程并不是马上转入

  阻塞，而是会持续的探测 `Locked` 位是否变为 0 ，这个过程即为自旋过程。自旋时间很短，但如果在自旋过程中

  发现锁已被释放，那么协程可以立即获取锁。此时即便有协程被唤醒也无法获取锁，只能再次阻塞。自旋的

  好处是，当加锁失败时不必立即转入阻塞，有一定机会获取到锁，这样可以避免协程的切换。

  **饥饿模式**：被唤醒的协程得到 CPU 后开始运行，此时发现锁已被抢占了，自己只好再次阻塞，不过阻塞前会

  判断自上次阻塞到本次阻塞经过了多长时间，如果超过 1ms 的话，会将 `Mutex` 标记为饥饿模式，然后再阻塞。

  处于饥饿模式下，不会启动自旋过程，也即一旦有协程释放了锁，那么一定会唤醒协程，被唤醒的

  协程将会成功获取锁，同时也会把等待计数减 1 。

- Go 的垃圾回收：标记清除法 -> 1.3 -> 三色标记法 -> 1.8 -> 三色标记法 + 混合写屏障