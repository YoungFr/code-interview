# 面经

Q: Linux 进程内存布局

<details><summary>A</summary>代码段、数据段（初始化、未初始化）、堆、栈</details>

Q: 内存溢出与内存泄漏

<details><summary>溢出</summary>检查算法和数据结构、释放资源、增加大小、内存池</details>

<details><summary>泄漏</summary>内存分析、智能指针、单元测试、日志监控、性能优化</details>

Q: extern "C" 语法？

<details><summary>A</summary>在 C++ 中按 C 语言方式进行名称修饰和链接。C++ 支持重载 -> 需要保存函数名及参数信息；C 只保存函数名</details>

Q: 内存管理的伙伴系统

<details><summary>A</summary>用于解决外部碎片问题。将内存块按照 2 的幂的大小组织成链表</details>

Q: 中断过程

<details><summary>A</summary>中断发生 -> 保存上下文 -> 中断向量表 -> 中断服务程序 -> 软件处理 -> 恢复上下文执行</details>

Q: 死循环/阻塞协程如何调度？

<details><summary>A</summary>使用 sysmon 线程对进行系统调用的（阻塞的）和长时间运行的协程进行抢占式调度</details>

Q: 什么是协程泄漏？

<details><summary>A</summary>由于不正确的管理或是过度使用导致协程资源无法被有效地释放从而占用大量内存空间的现象</details>

Q: 什么是 WebSocket 协议？

<details><summary>A</summary>服务器主动发送消息？HTTP 短轮询 -> HTTP 长轮询 -> 先使用 HTTP 进行协议升级 -> 支持全双工的 WebSocket 协议</details>

Q: 常见的限流模式？

A:

**单机限流**

流量计数器/固定窗口计数器：控制每个固定时间窗口内的请求次数；存在**窗口边缘流量猛增**问题。

滑动时间窗算法：平滑的基于某个时间片的流量统计。请求到来 -> 移除窗口内的过期请求 -> 统计当前窗口中的请求。

这两种模式只能决定是否限流，对于**超过阈值的流量只能丢弃而不是阻塞等待**。

漏桶算法：使用一个 FIFO 队列充当缓冲区，以固定速率处理请求。关键在于**桶的大小**和**处理速率**。

令牌桶算法：规定 1 秒内请求不超过 X 次，则每隔 1/X 秒放入一个令牌。请求必须获得令牌才能处理，桶有最大容量。

漏桶和令牌桶是思路相反的两种方法：**漏桶满时是流量过多而令牌桶满时是流量过少**。

**分布式限流**

集中统计：将所有服务的统计结果存入集中式缓存（Redis）并使用分布式锁进行并发控制。

数值化令牌桶算法：请求在网关处领取一定数值的令牌，每访问一个服务使用一定量的数值，小于 0 时重新申请。

