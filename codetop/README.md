# CodeTop

来自 [codetop](https://codetop.cc/home) 的按照出现频率高低排列的面试题目。

1. [无重复字符的最长字串](../algos/slidingwin/sw8.go) 滑动窗口

1. [反转链表](../algos/llist/llist23.go) 迭代反转 + 递归反转

1. [LRU 缓存机制](../algos/llist/llist35.go) 哈希表 + 双链表 + 每次 `Get` 和 `Put` 操作都将缓存项移到队头

1. [数组中的第 k 个最大元素](../algos/heap/heap74.go) 堆的删除（下沉）操作 + 原地建堆 + 三向切分快速选择

1. [k 个一组反转链表](../algos/llist/llist31.go) 分组反转链表

1. [三数之和](../algos/tp/tp3.go) 排序 + 双指针 + 元素去重

1. [最大子数组和](../algos/array/array13.go) 动态规划 - 详见 [README](../algos/README.md) 第 13 题

1. [手撕快速排序](./problems/c008_qsort.go) 切分函数的实现 + 主元的选取

1. [合并 2 个有序链表](../algos/llist/llist27.go) 迭代合并 + 递归合并

1. 两数之和

1. [最长回文子串](../algos/mddp/mddp93.go) 中心扩展法

1. 二叉树的层序遍历

1. [搜索旋转排序数组](../algos/bs/bs66.go) 先用二分查找找到最小值再确定在哪个区间上查找目标值

1. [岛屿数量](../algos/graph/graph51.go) 网格图的深度优先搜索

1. 有效的括号

1. [环形链表](../algos/llist/llist25.go) Floyd 判圈算法

1. 买卖股票的最佳时机

1. 二叉树的最近公共祖先

1. 合并两个有序数组

1. 全排列

1. [二叉树的锯齿形层次遍历](./problems/c021_zigzaglevel.go) 层次遍历中添加下一层节点时使用栈来实现锯齿形遍历

1. [反转链表 II](./problems/c022_revllist2.go) 需要部分反转的链表的头节点的 `Next` 域在反转后指向剩余未反转的部分

1. [螺旋矩阵](../algos/matrix/mat19.go) 按圈层从外向内打印矩阵

1. [相交链表](../algos/llist/llist22.go) 双指针获取两个链表的长度差

1. [合并 k 个升序链表](../algos/llist/llist34.go) 堆的插入（上浮）操作和删除（下沉）操作

1. 字符串相加

1. 最长上升子序列

1. [重排链表](./problems/c028_reorderllist.go) 交替合并两个链表

1. 接雨水

1. [环形链表 II](../algos/llist/llist26.go) 哈希表 + 快慢指针

1. [删除链表的倒数第 n 个节点](../algos/llist/llist29.go) 没啥意义的题

1. 二叉树中的最大路径和

1. 合并区间

1. 编辑距离

1. 二叉树的中序遍历

1. 最长公共子序列

1. 二分查找

1. [二叉树的右视图](./problems/c038_bitreerightview.go) 层序遍历记录每层最右边节点的值

1. [用栈实现队列](../algos/stkandq/twostacksqueue/twostacksqueue.go) 在 `popstk` 为空时要将 `pushstk` 中的元素全部 “倒入” `popstk` 中

1. 复原 IP 地址

1. 删除排序链表中的重复元素 II

1. 寻找两个正序数组的中位数

1. 下一个排列

1. [排序链表](../algos/llist/llist33.go) 对链表使用自顶向下和自底向上归并排序算法进行排序

1. [x 的平方根](./problems/c045_sqrtx.go) 二分查找第一个满足自身的平方和大于等于 x 的元素

1. 字符串转换整数

1. 爬楼梯

1. 括号生成

1. 两数相加

1. 滑动窗口最大值

1. 比较版本号

1. 缺失的第一个正数

1. 链表中倒数第 k 个节点

1. [最小覆盖子串](../algos/substr/substr12.go) 使用 `check` 函数的滑动窗口

1. 子集

1. [零钱兑换](../algos/dp/dp85.go) 动态规划 - 详见 [README](../algos/README.md) 第 85 题

1. 从前序与中序遍历序列构造二叉树

1. [最小栈](../algos/stkandq/minstack/minstack.go) 使用辅助栈保存当前的最小值

1. 最长有效括号

1. 翻转字符串里的单词

1. 字符串相乘

1. 对称二叉树

1. 平衡二叉树

1. 二叉树的前序遍历

1. 二叉树的最大深度

1. 求根到叶子节点数字之和

1. [二叉树的直径](../algos/bitree/bitree40.go) 遍历每个节点并计算以每个节点作为根节点时的最长路径并更新最大值

1. 验证二叉搜索树

1. [旋转图像](../algos/matrix/mat20.go) 根据矩阵各种对称的转移式进行推导

1. 组合总和

1. 路径总和 II

1. 字符串解码

1. 用 `Rand7()` 实现 `Rand10()`

1. 最小路径和

1. [在排序数组中查找元素的第一个和最后一个位置](../algos/bs/bs65.go)

   利用 `bsearch(nums, target)` 和 `bsearch(nums, target+1) - 1` 寻找元素的第一个和最后一个位置

1. 最大正方形

1. 搜索二维矩阵 II

1. [回文链表](../algos/llist/llist24.go) 快慢指针寻找中间节点 + 反转一半链表

1. 路径总和

1. 寻找峰值

1. 最长公共前缀

1. [多数元素](../algos/skills/skills97.go) Boyer-Moore 投票算法

1. 最长重复子数组

1. 翻转二叉树

1. 不同路径

1. 最长连续序列

1. 二叉树最大宽度

1. 买卖股票的最佳时机 II

1. 乘积最大子数组

1. 岛屿的最大面积

1. 删除排序链表中的重复元素

1. 基本计算器 II

1. [打家劫舍](../algos/dp/dp83.go) 动态规划 - 详见 [README](../algos/README.md) 第 83 题

1. 最大数

1. 单词拆分

1. [两两交换链表中的节点](../algos/llist/llist31.go) 第 5 题 k 个一组反转链表中 k = 2 时的情况

1. 手撕堆排序

1. 二叉树的序列化与反序列化

1. 移动零

1. 和为 k 的子数组

1. 长度最小的子数组

1. [寻找旋转排序数组中的最小值](../algos/bs/bs67.go)

   数组满足前半部分都大于 `nums[-1]` 而后半部分都小于等于 `nums[-1]` 且

   答案是第一个满足小于等于 `nums[-1]` 的元素

1. 验证 IP 地址

1. LFU 缓存

1. 复制带随机指针的链表

1. 基本计算器

1. 每日温度

1. 用两个栈实现队列

1. 只出现一次的数字

1. 全排列 II

1. 课程表

1. 对角线遍历

1. 移掉 k 位数字

1. 盛最多水的容器

1. 二叉搜索树与双向链表

1. 二叉树的完全性校验

1. 检测循环依赖

1. 手撕归并排序

1. 买卖股票的最佳时机 III

1. 排序奇升偶降链表

1. 单词搜索

1. 跳跃游戏

1. 二叉搜索树的第 k 大节点

1. `Pow(x, n)`

1. 数组中的逆序对

1. 旋转链表

1. 组合总和 II

1. 删除二叉搜索树中的节点

1. 删除排序数组中的重复项

1. 整数反转

1. 零钱兑换 II

1. [搜索二维矩阵](../algos/bs/bs64.go) 将二维矩阵的行列下标对应到一维数组的下标后进行二分查找

1. 螺旋矩阵 II

1. 最小的 k 个数

1. 二叉树的后序遍历

1. 青蛙跳台阶问题

1. 连续子数组的最大和

1. [荷兰国旗问题](../algos/skills/skills98.go) 以 1 为主元进行三向切分

1. 字典序的第 k 小数字

1. 树的子结构
