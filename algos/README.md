LC [Hot 100](https://leetcode.cn/studyplan/top-100-liked/) and More...

# 哈希

1. [两数之和](./hash/hash1.go) 构建键为元素、值为下标的哈希表

2. 字母异位词分组

3. 最长连续序列

# 双指针

4. 移动零

5. 盛最多水的容器

6. [三数之和](./tp/tp6.go) 排序 + 双指针 + 元素去重

7. [接雨水](./tp/tp7.go) 前后缀分解 or 双指针

# 滑动窗口

8. [无重复字符的最长子串](./slidingwin/sw8.go) 滑动窗口

9. 找到字符串中所有字母异位词

# 子串

10. 和为 k 的子数组

11. 滑动窗口最大值

12. [最小覆盖子串](./substr/substr12.go) 使用 `check` 函数的滑动窗口

# 普通数组

13. [最大子数组和](./array/array13.go) 数组元素 `f[i]` 表示以 `nums[i]` 结尾的子数组的最大和

    ```
    f[i = 0] = nums[0]
               只有一个元素的情况
    f[i > 0] = nums[i] if f[i-1]<0 else nums[i]+f[i-1]
               如果以 nums[i-1] 结尾的子数组的最大和已经小于零
               就不应该把它加入以 nums[i] 结尾的子数组中
             = max(nums[i], nums[i]+f[i-1])
    ```

14. [合并区间](./array/array14.go) 将区间按照左端点从小到大排序后所有可以合并的区间是连续的

15. 轮转数组

16. 除自身以外数组的乘积

17. 缺失的第一个正数

# 矩阵

18. 矩阵置零

19. [螺旋矩阵](./matrix/mat19.go) 按圈层从外向内打印矩阵

20. [旋转图像](./matrix/mat20.go) 根据矩阵各种对称的转移式进行推导

21. 搜索二维矩阵 II

# 链表

22. [相交链表](./llist/llist22.go) 双指针获取两个链表的长度差

23. [反转链表](./llist/llist23.go) 迭代反转 + 递归反转

24. [回文链表](./llist/llist24.go) 快慢指针寻找中间节点 + 反转一半链表

25. [判断链表中是否有环](./llist/llist25.go) Floyd 判圈算法

26. [寻找链表中环的入口](./llist/llist26.go) 哈希表 + 快慢指针

27. [合并 2 个有序链表](./llist/llist27.go) 迭代合并 + 递归合并

28. 两数相加

29. [删除链表的倒数第 n 个节点](./llist/llist29.go) 没啥意义的题

30. [2 个一组翻转链表](./llist/llist30.go) 分组反转链表

31. [k 个一组翻转链表](./llist/llist31.go) 分组反转链表

32. 随机链表的复制

33. [排序链表](./llist/llist33.go) 对链表使用自顶向下和自底向上归并排序算法进行排序

34. [合并 k 个升序链表](./llist/llist34.go) 堆的插入（上浮）操作和删除（下沉）操作

35. [LRU 缓存](./llist/llist35.go) 哈希表 + 双链表 + 每次 `Get` 和 `Put` 操作都将缓存项移到队头

# 二叉树

36. [二叉树的中序遍历](./bitree/bitree36.go) 不断压入当前节点的左孩子，如果为空了就打印栈顶元素然后转向右边

37. [二叉树的最大深度](./bitree/bitree40.go) 左右子树最大深度的较大值加一

38. 翻转二叉树

39. 对称二叉树

40. [二叉树的直径](./bitree/bitree40.go) 遍历每个节点并计算以每个节点作为根节点时的最长路径并更新最大值

41. [二叉树的层序遍历](../codetop/problems/c038_bitreerightview.go) 队列的经典应用

42. 将有序数组转化为二叉树

43. [验证二叉搜索树](./bitree/bitree43.go) 使用迭代式算法判断中序遍历结果是否为单调递增的

44. 二叉搜索树中第 k 小的元素

45. [二叉树的右视图](./problems/c038_bitreerightview.go) 层序遍历记录每层最右边节点的值

46. 二叉树展开为链表

47. 从前序与中序遍历序列构造二叉树

48. 路径总和 III

49. 二叉树的最近公共祖先

50. 二叉树中的最大路径和

# 图论

51. [岛屿数量](./graph/graph51.go) 网格图的深度优先搜索

52. 腐烂的橘子

53. [课程表](./graph/graph53.go) 对 DAG 进行拓扑排序的 Kahn 算法

54. 实现前缀树

# 回溯

55. [全排列](./backtrack/bt55.go) 排列型回溯

56. [子集](./backtrace/bt56.go) 子集型回溯例题 => 每个位置的元素都有选或不选两种可能

57. [电话号码的字母组合](./backtrace/bt57.go) 回溯例题 or 通过 DFS 形成决策树并记录第 n 层的结果

    ```
    回溯三问：当前操作？ -> 子问题？ -> 下一个子问题？
    ```

58. [组合总和](./backtrack/bt58.go)

59. 括号生成

60. 单词搜索

61. [分割回文串](./backtrace/bt61.go) 子集型回溯 => 每个字符后边的逗号都有选或不选两种可能并且最后一个字符后边的逗号必须选择

62. N 皇后

# 二分查找

63. [搜索插入位置](./bs/bs63.go) 二分查找找到数组中第一个大于等于 target 的元素的下标

64. [搜索二维矩阵](./bs/bs64.go) 将二维矩阵的行列下标对应到一维数组的下标后进行二分查找

65. [在排序数组中查找元素的第一个和最后一个位置](./bs/bs65.go) `bsearch(nums, target) & bsearch(nums, target+1) - 1`

66. [搜索旋转排序数组](./bs/bs66.go) 先用二分查找找到最小值再确定在哪个区间上查找目标值

67. [寻找旋转排序数组中的最小值](./bs/bs67.go)

    数组满足前半部分都大于 `nums[-1]` 而后半部分都小于等于 `nums[-1]` 且

    答案是第一个满足小于等于 `nums[-1]` 的元素

68. 寻找两个正序数组的中位数

# 栈

69. [有效的括号](./stkandq/stk61.go) 利用栈进行括号匹配

70. 最小栈

71. [字符串解码](./stkandq/stk63.go) 数字栈 + 字符串栈

72. 每日温度

73. 柱状图中最大的矩形

# 堆

74. [数组中的第 k 个最大元素](./heap/heap74.go) 堆的删除（下沉）操作 + 原地建堆 + 三向切分快速选择

75. [前 k 个高频元素](./heap/heap75.go) 建立大顶堆后进行 k 次删除获取前 k 大的值

76. [数据流的中位数](./heap/heap76.go) 大顶堆保存数组前半部分最大值 + 小顶堆保存数组后半部分最小值

# 贪心算法

77. [买卖股票的最佳时机](./greedy/greedy77.go) 用一个变量维护前 `i-1` 天的最小价格作为买入价格，然后枚举卖出价格来获取最大利润

78. 跳跃游戏

79. 跳跃游戏 II

80. 划分字母区间

# 动态规划

81. [爬楼梯](./dp/dp81.go) 斐波那契数列

82. 杨辉三角

83. [打家劫舍](./dp/dp83.go) 数组元素 `f[i]` 表示偷窃第 `0` 间到第 `i` 间房屋能得到的最高金额

    ```
    f[i = 0] = nums[0]
               只有一间房可以偷
    f[i = 1] = max(nums[0], nums[1])
               有两间房时应该偷金额较大的一间
    f[i > 1] = max(nums[i] + f[i-2],    f[i-1])
                          ^                ^
                          |                |
               结果是 [偷第 i 间房] 与 [不偷第 i 间房] 的较大值
    ```

84. 完全平方数

85. [零钱兑换](./dp/dp85.go) 数组元素 `f[i]` 表示组成金额 `i`​ 所需的最少硬币数

    ```
    f[i < 0] = -1
               组成小于零的金额是不可能的
    f[i = 0] = 0
               组成的金额为零则不需要硬币
    f[i > 0] = min(f[i-c[j]]) + 1
               枚举组成金额 i 的最后一枚硬币的面值 c[j] 的大小
               如果所有 f[i-c[j]] 都等于 -1 则无法组成大小为 i 的金额
               否则结果是所有大于等于零的 f[i-c[j]] 中的最小值再加一
    ```

86. [单词拆分](./dp/dp86.go) 数组元素 `f[i]` 表示子串 `s[0...i]` 能否使用字典中的单词拼接而成

    ```
    f[i = 0] = has(s[0...0])
               子串 s[0...0] 在字典中则能拼成否则拼不成
    f[i > 0] = OR(f[0...j] && has[s[j+1...i]]) || has[s[0...i]], 0 <= j < i
               对于子串 s[0...i] 枚举它的所有前缀 s[0...j] 字符串
               如果前缀能拼成且对应的后缀 s[j+1...i] 在字典中则 s[0...i] 能拼成
               最终答案是所有情况取逻辑或的结果
    ```

87. 最长递增子序列

88. 乘积最大子数组

89. 分割等和子集

90. 最长有效括号

# 多维动态规划

91. 不同路径

92. 最小路径和

93. [最长回文子串](./mddp/mddp93.go) 中心扩展法

94. 最长公共子序列

95. 编辑距离

# 技巧

96. 只出现一次的数字

97. [多数元素](./skills/skills97.go) Boyer-Moore 投票算法

98. [荷兰国旗问题](./skills/skills98.go) 以 1 为主元进行三向切分

99. [下一个排列](./skills/skills99.go) 将一个尽可能靠右的数和它右侧比它大的数中最小的那个交换

100. 寻找重复数
