LC [Hot 100](https://leetcode.cn/studyplan/top-100-liked/) and More...

# 哈希

1. 两数之和

2. 字母异位词分组

3. 最长连续序列

# 双指针

4. 移动零

5. 盛最多水的容器

6. [三数之和](./tp/tp3.go) 排序 + 双指针 + 元素去重

7. 接雨水

# 滑动窗口

8. [无重复字符的最长子串](./slidingwin/sw8.go) 滑动窗口

9. 找到字符串中所有字母异位词

# 子串

10. 和为 k 的子数组

11. 滑动窗口最大值

12. [最小覆盖子串](./substr/substr12.go) 使用 `check` 函数的滑动窗口

# 普通数组

13. [最大子数组和](./array/array13.go) 数组元素 `f[i]` 表示以 `nums[i]` 结尾的子数组的最大和

    ```
    f[i = 0] = nums[0]
               只有一个元素的情况
    f[i > 0] = nums[i] if f[i-1]<0 else nums[i]+f[i-1]
               如果以 nums[i-1] 结尾的子数组的最大和已经小于零
               就不应该把它加入以 nums[i] 结尾的子数组中
             = max(nums[i], nums[i]+f[i-1])
    ```

# 矩阵

19. [螺旋矩阵](./matrix/mat19.go) 按圈层从外向内打印矩阵

20. [旋转图像](./matrix/mat20.go) 根据矩阵各种对称的转移式进行推导

# 链表

22. [相交链表](./llist/llist22.go) 双指针获取两个链表的长度差

23. [反转链表](./llist/llist23.go) 迭代反转 + 递归反转

24. [回文链表](./llist/llist24.go) 快慢指针寻找中间节点 + 反转一半链表

25. [判断链表中是否有环](./llist/llist25.go) Floyd 判圈算法

26. [寻找链表中环的入口](./llist/llist26.go) 哈希表 + 快慢指针

27. [合并 2 个有序链表](./llist/llist27.go) 迭代合并 + 递归合并

28. 两数相加

29. [删除链表的倒数第 n 个节点](./llist/llist29.go) 没啥意义的题

30. [2 个一组翻转链表](./llist/llist30.go) 分组反转链表

31. [k 个一组翻转链表](./llist/llist31.go) 分组反转链表

32. 随机链表的复制

33. [排序链表](./llist/llist33.go) 对链表使用自顶向下和自底向上归并排序算法进行排序

34. [合并 k 个升序链表](./llist/llist34.go) 堆的插入（上浮）操作和删除（下沉）操作

35. [LRU 缓存](./llist/llist35.go) 哈希表 + 双链表 + 每次 `Get` 和 `Put` 操作都将缓存项移到队头

# 二叉树

36. [二叉树的中序遍历](./bitree/bitree36.go) 不断压入当前节点的左孩子，如果为空了就打印栈顶元素然后转向右边

37. 二叉树的最大深度

38. 翻转二叉树

39. 对称二叉树

40. [二叉树的直径](./bitree/bitree40.go) 遍历每个节点并计算以每个节点作为根节点时的最长路径并更新最大值

41. 二叉树的层序遍历

42. 将有序数组转化为二叉树

43. 验证二叉搜索树

44. 二叉搜索树中第 k 小的元素

45. [二叉树的右视图](./problems/c038_bitreerightview.go) 层序遍历记录每层最右边节点的值

# 图论

51. [岛屿数量](./graph/graph51.go) 网格图的深度优先搜索

# 二分查找

63. [搜索插入位置](./bs/bs63.go) 二分查找找到数组中第一个大于等于 target 的元素的下标

64. [搜索二维矩阵](./bs/bs64.go) 将二维矩阵的行列下标对应到一维数组的下标后进行二分查找

65. [在排序数组中查找元素的第一个和最后一个位置](./bs/bs65.go)

    利用 `bsearch(nums, target)` 和 `bsearch(nums, target+1) - 1` 寻找元素的第一个和最后一个位置

66. [搜索旋转排序数组](./bs/bs66.go) 先用二分查找找到最小值再确定在哪个区间上查找目标值

67. [寻找旋转排序数组中的最小值](./bs/bs67.go)

    数组满足前半部分都大于 `nums[-1]` 而后半部分都小于等于 `nums[-1]` 且

    答案是第一个满足小于等于 `nums[-1]` 的元素

68. 寻找两个正序数组的中位数

# 堆

74. [数组中的第 k 个最大元素](./heap/heap74.go) 堆的删除（下沉）操作 + 原地建堆 + 三向切分快速选择

75. [前 k 个高频元素](./heap/heap75.go) 建立大顶堆后进行 k 次删除获取前 k 大的值

76. [数据流的中位数](./heap/heap76.go) 大顶堆保存数组前半部分最大值 + 小顶堆保存数组后半部分最小值

# 贪心算法

77. [买卖股票的最佳时机](./greedy/greedy77.go) 用一个变量维护前 `i-1` 天的最小价格作为买入价格，然后枚举卖出价格来获取最大利润

# 动态规划

83. [打家劫舍](./dp/dp83.go) 数组元素 `f[i]` 表示偷窃第 `0` 间到第 `i` 间房屋能得到的最高金额

    ```
    f[i = 0] = nums[0]
               只有一间房可以偷
    f[i = 1] = max(nums[0], nums[1])
               有两间房时应该偷金额较大的一间
    f[i > 1] = max(nums[i] + f[i-2],    f[i-1])
                          ^                ^
                          |                |
               结果是 [偷第 i 间房] 与 [不偷第 i 间房] 的较大值
    ```

85. [零钱兑换](./dp/dp85.go) 数组元素 `f[i]` 表示组成金额 `i`​ 所需的最少硬币数

    ```
    f[i < 0] = -1
               组成小于零的金额是不可能的
    f[i = 0] = 0
               组成的金额为零则不需要硬币
    f[i > 0] = min(f[i-c[j]]) + 1
               枚举组成金额 i 的最后一枚硬币的面值 c[j] 的大小
               如果所有 f[i-c[j]] 都等于 -1 则无法组成大小为 i 的金额
               否则结果是所有大于等于零的 f[i-c[j]] 中的最小值再加一
    ```

86. 单词拆分

# 多维动态规划

93. [最长回文子串](./mddp/mddp93.go) 中心扩展法

# 技巧

97. [多数元素](./skills/skills97.go) Boyer-Moore 投票算法

98. [荷兰国旗问题](./skills/skills98.go) 以 1 为主元进行三向切分
