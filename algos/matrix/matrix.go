package main

// ___     ___           ___    __    __    ______   .___________.    __    ___     ___
// |__ \   / _ \         /  /   |  |  |  |  /  __  \  |           |   /_ |  / _ \   / _ \
//    ) | | | | |       /  /    |  |__|  | |  |  |  | `---|  |----`    | | | | | | | | | |
//   / /  | | | |      /  /     |   __   | |  |  |  |     |  |         | | | | | | | | | |
//  / /_  | |_| |     /  /      |  |  |  | |  `--'  |     |  |         | | | |_| | | |_| |
// |____|  \___/     /__/       |__|  |__|  \______/      |__|         |_|  \___/   \___/

// LC 48 - 旋转图像
// https://leetcode.cn/problems/rotate-image/description/

func Rotate(matrix [][]int) {
	// 矩阵各种对称的转移式如下
	// 上下对称 => 列不变: A[i][j] -> A[n-1-i][j]
	// 左右对称 => 行不变: A[i][j] -> A[i][n-1-j]
	// 主对角线对称 => 行列互换: A[i][j] -> A[j][i]
	// 副对角线对称 => 行列均变且互换: A[i][j] -> A[n-1-j][n-1-i]

	// 对于此类旋转、对称的题目
	// 先分析下变换前后的关系，比如对于本题的第 2 个示例有
	//
	// 5: [0, 0] -> [0, 3]
	// 7: [2, 3] -> [3, 1]
	// 3: [2, 1] -> [1, 1]
	// ...
	//
	// 可以看出，变换后的行是原来的列的值，变换后的列和变换前的行的和是 n-1
	// 所以转移式是: A[i][j] -> A[j][n-1-i]
	// 然后分析下怎么从 A[i][j] 变换得到 A[j][n-1-i]
	// 很明显，将 A[i][j] 上下对称的结果 A[n-1-i][j] 再行列互换就是 A[j][n-1-i]
	// 所以旋转方法是先上下对称再沿主对角线对称

	n := len(matrix)
	// 上下对称时遍历矩阵的上半部分
	for j := 0; j < n; j++ {
		for i := 0; i < n/2; i++ {
			matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]
		}
	}
	// 主对角线对称时遍历矩阵的上三角部分
	for i := 0; i < n; i++ {
		for j := i; j < n; j++ {
			matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
		}
	}
}
